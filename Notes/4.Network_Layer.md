# Network Layer (Layer 3) â€“ Explained for Interviews

The Network Layer is where packets learn how to **travel from one computer to another**, even if they are on completely different networks.  
Think of it like **Google Maps for data**: it decides the route, ensures the addresses are correct, and handles traffic issues on the way.

---

## 1. Why Do We Need the Network Layer?

The Data Link Layer only ensures communication between two directly connected machines.  
But what if your laptop in Delhi needs to talk to a server in California?  
Thatâ€™s where the Network Layer comes in â€” it makes **end-to-end delivery** possible.

### Key Responsibilities
- **Routing**: Choosing the best path through routers (like roads on a map).
- **Logical Addressing**: Assigning IP addresses so each device can be found, regardless of location.
- **Internetworking**: Connecting very different networks (LANs, WANs, WiFi, Ethernet).
- **Congestion Control**: Avoiding "traffic jams" when too many packets overload the network.
- **QoS (Quality of Service)**: Making sure important traffic (video calls, payments) gets priority.

---

## 2. How the Network Layer Works

### Store-and-Forward
Routers donâ€™t just pass packets blindly.  
They **store** each packet, **check it for errors**, and then **forward it** to the next hop.

### Connection-Oriented vs. Connectionless
Two service models are possible:

| Feature | Virtual Circuits (Connection-Oriented) | Datagrams (Connectionless) |
|---------|-----------------------------------------|-----------------------------|
| Analogy | Telephone call (dedicated path) | Postal system (independent letters) |
| Setup   | Connection must be established | No setup, packets sent directly |
| Address | Short Virtual Circuit ID (VCI) | Full destination IP in every packet |
| Order   | Packets arrive in order | Packets may arrive out of order |
| Reliability | Easier to guarantee QoS | Best-effort, handled by higher layers |

ðŸ‘‰ The **Internet uses connectionless (datagrams)** because it keeps the network simple and leaves reliability to TCP.

---

## 3. What Happens to Data?

- The Transport Layer hands over **segments**.  
- The Network Layer adds its **own header** (with source & destination IPs).  
- This becomes a **packet (datagram)**.  
- The packet is passed to the Data Link Layer, which frames it for the actual wire.

### Routing vs. Forwarding
- **Routing**: The big-picture planning (building/updating routing tables).  
- **Forwarding**: The micro action (looking up the destination IP and pushing the packet to the right output link).

---

## 4. Internet Protocol (IP)

The **Internet runs on IP**, which is *best-effort* â€” it tries its best, but doesnâ€™t promise delivery.

## IPv4 Basics
### IPv4 Header

The **IPv4 header** is the portion of an IP packet that contains control information, such as source/destination addresses, packet length, fragmentation info, and more. The standard header is **20 bytes (160 bits)** long without options; it can be longer if options are included.

---

### IPv4 Header Format (20 Bytes)

| Field | Size (bits) | Description |
| :--- | :--- | :--- |
| **Version** | 4 | IP version number (IPv4 = 4) |
| **IHL (Internet Header Length)** | 4 | Number of 32-bit words in the header; minimum is 5 (20 bytes) |
| **Type of Service (ToS) / DSCP** | 8 | Quality of Service and priority flags |
| **Total Length** | 16 | Length of entire packet (header + data) in bytes |
| **Identification** | 16 | Unique ID for packet; used for fragmentation |
| **Flags** | 3 | Control flags for fragmentation: <br>0 â€“ Reserved<br>1 â€“ Don't Fragment (DF)<br>2 â€“ More Fragments (MF) |
| **Fragment Offset** | 13 | Position of this fragment in the original packet (in 8-byte units) |
| **Time to Live (TTL)** | 8 | Maximum hops the packet can traverse; decremented by each router |
| **Protocol** | 8 | Indicates the encapsulated protocol (e.g., TCP = 6, UDP = 17, ICMP = 1) |
| **Header Checksum** | 16 | Error detection for the header only |
| **Source Address** | 32 | IPv4 address of the sender |
| **Destination Address** | 32 | IPv4 address of the receiver |
| **Options (optional)** | Variable | Rarely used; can include security, timestamp, routing info |
| **Padding** | Variable | Added to make the header a multiple of 32 bits |

---

## Key Points

* Minimum header size: 20 bytes (IHL = 5)  
* Maximum header size: 60 bytes (IHL = 15)  
* Header fields **control routing, fragmentation, and integrity**, while the data portion carries the actual payload.  
* The **TTL field** prevents packets from looping infinitely in the network.  
* The **Protocol field** allows the IP layer to pass data to the correct transport-layer protocol.  

---

## Diagram (Simplified)



## Addressing
addressing is the method used to uniquely identify devices or hosts so that data can be sent to the correct destination.

---

### i) Classless InterDomain Routing (CIDR)

**CIDR**, pronounced "cider", replaced rigid classful addressing (A, B, C) with **variable-length prefixes**, helping reduce routing table size and conserve IPv4 addresses.

### CIDR Notation and Prefix Length

- **Format:** `x.y.z.t/n` where `x.y.z.t` is an address in the block and `/n` is the **prefix length**.
- **Prefix Meaning:** The first `n` bits indicate the **network portion**, and the remaining `32 - n` bits form the **host portion**.
- **Subnet Mask:** The prefix corresponds to a mask of `n` contiguous 1s followed by 0s, defining the network.

### Advantages of CIDR

- **Address Aggregation:** Multiple smaller address blocks can be combined into a single **supernet** for advertisement, reducing routing table entries.
- **Scalability:** Routers store routes for **prefixes** rather than individual hosts, drastically lowering memory and computation requirements.
- **Forwarding Efficiency:** Routers forward packets using only the network portion of the address until it reaches the destination network.

### Longest Matching Prefix

- **Rule:** If multiple prefixes match a destination IP, the router chooses the **longest (most specific) prefix**.
- **Use Case:** Handles exceptions, e.g., a small `/22` block routed differently from a larger `/19` block.
- **Implementation:** Requires sophisticated table lookup algorithms for fast forwarding, often implemented in custom VLSI router hardware.

---

### ii) Network Address Translation (NAT)

**NAT** solves IPv4 scarcity by allowing multiple devices in a private network to share a single public IP address when communicating with the Internet.

### Purpose and Mechanism

- **Private IPs:** Reserved ranges (e.g., `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) are unique internally but not globally routable.
- **Translation Device:** The **NAT box** (router or firewall) translates addresses:
  - **Outgoing:** Converts the internal **source IP** to the public IP.
  - **Incoming:** Converts the external **destination IP** back to the correct internal host.

### Port Numbers for Mapping

- **Challenge:** Multiple internal hosts share the same public IP.
- **Solution:** Use **Transport Layer port numbers** to differentiate connections.
- **Operation:**
  1. NAT records the internal IP and source port, optionally modifying the port for uniqueness.
  2. Incoming replies are matched via the NAT table using the destination port, which is mapped back to the original internal IP and port.

> NAT effectively allows many hosts to appear as a single external IP, conserving public addresses while maintaining correct routing for replies.

---

## Subnetting and Supernetting in IPv4

The sources discuss **subnetting** and **supernetting** extensively within the context of **IPv4 logical addressing** at the Network Layer, emphasizing how these techniques were developed to manage the finite 32-bit address space and improve routing efficiency.

---

## Subnetting

**Subnetting** is the process of splitting a single, large block of IP addresses (a network number) into several smaller parts for internal use as multiple logical networks, called **subnets**.

### Purpose and Mechanism

* **Internal Organization:** Allows an organization to divide a large block of IP addresses into contiguous groups for separate subnets.  
* **External Transparency:** The organization still appears as a **single network** externally.  
* **Routing and Hierarchy:** External routers forward packets based on the **network portion** of the address; subnetting adds an intermediate level (network â†’ subnet â†’ host).  
* **Router Action (Inside the Network):** Routers use the **subnet mask** to determine which subnet a packet belongs to.  
* **Management:** Subnet divisions can be updated internally without affecting external routing databases.

### Subnet Mask and Prefix Length

* Prefix length ($n$ in $x.y.z.t/n$) is **extended** to define the subnet portion.  
* The subnet mask increases the number of '1' bits to include part of the host space in the network prefix.  
* Example: A block with prefix $/26$ (64 addresses) can be divided into subblocks of 32, 16, and 16 addresses with masks $/27$, $/28$, and $/28$.

---

## Supernetting and CIDR

**Supernetting** solves the problem of insufficient address space in Class B and C networks by combining multiple small prefixes into a single larger prefix.

### Mechanism

* **Combining Networks:** Merge contiguous Class C blocks to form a **supernet**.  
* **Mask Adjustment:** Reduce the number of '1' bits in the mask. Example: Four $/24$ blocks â†’ one $/22$ supernet.


---

## CIDR vs. Classful Addressing

| Feature | Classful Addressing | Classless Addressing (CIDR) |
| :--- | :--- | :--- |
| **Hierarchy** | Fixed (Class A/B/C) | Flexible (prefixes of varying sizes) |
| **Subnetting** | Extend default mask | Natural division of blocks |
| **Supernetting** | Combine Class C blocks | Achieved via route aggregation |
| **Routing** | Simple table lookup | Longest mask matching required |
| **Efficiency** | Wasted address space | Efficient division of address space |

---

## IPv4 Addressing

The information regarding IPv4 addresses includes the now largely obsolete **classful addressing** scheme, number of hosts per network, special addresses, address ranges, and **private IP addresses**.

---

### 1. Classful Addressing (Classes A through E)

Before **CIDR (Classless InterDomain Routing)** was implemented (~1993), IPv4 addresses were divided into five classes. The class can be determined from the first few bits of the 32-bit address or the first byte value.

| Class | First Bits (Binary) | First Byte Range | Application |
| :--- | :--- | :--- | :--- |
| **A** | 0xxxxxxx | 0 â€“ 127 | Unicast |
| **B** | 10xxxxxx | 128 â€“ 191 | Unicast |
| **C** | 110xxxxx | 192 â€“ 223 | Unicast |
| **D** | 1110xxxx | 224 â€“ 239 | Multicast |
| **E** | 1111xxxx | 240 â€“ 255 | Reserved for future use |

### Address Range

Full IPv4 range: `0.0.0.0` to `255.255.255.255`. Each class defines a portion of this range.

### Fixed Block Size (Number of Hosts per Network)

| Class | Netid Bits | Hostid Bits | Max Hosts per Network |
| :--- | :--- | :--- | :--- |
| **A** | 8 | 24 | 16,777,216 |
| **B** | 16 | 16 | 65,536 |
| **C** | 24 | 8 | 256 |

**Wastage:** Fixed division caused inefficiency. Class B networks were often too large for most organizations, and Class A networks (16 million addresses) were almost never fully utilized.

---

### 2. Special IP Addresses and Reserved Ranges

| Address | Description | Binary Notation | Purpose |
| :--- | :--- | :--- | :--- |
| `0.0.0.0` | This host / current network | 32 bits 0 | Used by hosts when booting |
| Network address | Network number + host 0s | Network prefix + 0s | First address of a block; not assigned to any device |
| Broadcast address | All 1s (`255.255.255.255`) | 32 bits 1 | Broadcast on local network |
| Distant broadcast | Network number + host 1s | Network prefix + 1s | Broadcast to distant LANs (often disabled) |
| Loopback | `127.x.y.z` | `01111111` first byte | Testing; processed locally as incoming packets |

---

### 3. Private IP Address Ranges (NAT)

Due to IPv4 scarcity, **private IP addresses** were reserved for internal networks. These addresses are not routable on the Internet. NAT devices translate these private addresses to a **public IP address** before packets exit to the Internet.

| Private Range | CIDR Notation | Total Hosts |
| :--- | :--- | :--- |
| `10.0.0.0 â€“ 10.255.255.255` | /8 | 16,777,216 |
| `172.16.0.0 â€“ 172.31.255.255` | /12 | 1,048,576 |
| `192.168.0.0 â€“ 192.168.255.255` | /16 | 65,536 |

------


## Fragmentation and MTU

When packets are **bigger than a linkâ€™s MTU**, they must be **split** into smaller pieces called **fragments** to pass through the network.

---

## What is MTU?

- **MTU (Maximum Transmission Unit)** is the **largest size of a single packet** (or frame) that a network link can carry.  
- Different network types have different MTUs:  
  - Ethernet: 1500 bytes  
  - Wi-Fi: 2304 bytes  
- If a packet exceeds the MTU, it **cannot travel through that link as a single unit**.

---

## Why Packets Must Be Split

Imagine sending a **large box through a small doorway**. You canâ€™t push the whole box in at once, so you break it into smaller boxes that fit.  

Similarly, when a packet is **larger than the MTU**, it is divided into smaller **fragments**, which are then reassembled at the destination.

---

## How Fragmentation Works

1. **Original Packet:** A packet of **4000 bytes** must traverse a link with **MTU = 1500 bytes**.  
2. **Splitting:** The packet is divided into 3 fragments:  
   - Fragment 1 â†’ 1500 bytes  
   - Fragment 2 â†’ 1500 bytes  
   - Fragment 3 â†’ 1000 bytes  
3. **Headers:** Each fragment gets its **own IP header** containing:  
   - Fragment number  
   - Reassembly information  
4. **Reassembly:** The destination host **reconstructs the original packet** using the information in the fragment headers.

---

## Important Notes

- **IPv4:** Routers can fragment packets if necessary.  
- **IPv6:** Only the **source host** fragments packets; routers do not fragment.  

---

ðŸ’¡ **Analogy:** Sending a long letter in multiple envelopes because the mailbox can only hold a certain size.

---
### IPv6
- **128-bit addresses** (goodbye IPv4 exhaustion).
- **Simpler header** (40 bytes, fixed).
- **No header checksum** (higher layers handle it).
- **Extension headers** for optional features.
- **Flow Label** for QoS-like handling of special traffic.

---

## 5. Routing Protocols

**Network Layer Routing Algorithms**

The **Network Layer** is primarily responsible for **routing packets** from the source to the destination across multiple hops. This requires specialized **routing algorithms** to determine the best paths. The two major adaptive routing algorithm types are **Distance Vector Routing** and **Link State Routing**.

---

## i. Distance Vector Routing (e.g., RIP)

**Distance Vector Routing** works by having each router maintain a **table (vector)** showing the best-known distance (cost) to every destination and the outgoing link to reach it.

### How It Works
- **Routing Table:** Each router stores the distance (or cost) to every other router and the preferred outgoing link.
- **Metric:** Distance can be **hop count** (as in RIP) or other measures like delay.
- **Sharing Updates:** Routers periodically send their tables to immediate neighbors (**periodic updates**) and whenever a change occurs (**triggered updates**).
- **Updating Tables:** When a router receives a neighbor's vector, it calculates the new distance to each destination via that neighbor. The shortest distance is chosen.

> RIP is an example of **distance vector routing**, historically based on the **distributed Bellman-Ford algorithm**.

### Main Problem: Slow Convergence (Count-to-Infinity)
- Distance vector reacts quickly to good news but slowly to bad news (e.g., link failures).
- **Count-to-Infinity Problem:** After a link failure, routers may incorrectly report paths through each other, causing path costs to increment slowly toward infinity, potentially looping packets.
- **Heuristics to Mitigate:**
  - **Defining Infinity:** Limit the maximum path length (e.g., 16 in RIP) for faster stabilization.
  - **Split Horizon:** Avoid advertising a route back to the neighbor from which it was learned.
  - **Poison Reverse:** Explicitly report infinite distance to the neighbor it was learned from.

---

## ii. Link State Routing (e.g., OSPF)

**Link State Routing** addresses distance vectorâ€™s slow convergence by distributing the **entire network topology** to each router. Each router then independently computes optimal paths.

### Mechanism: Five Steps
1. **Discover Neighbors:** Send **HELLO packets** to find adjacent routers.
2. **Set Link Costs:** Assign a cost metric to each link (e.g., based on bandwidth or measured delay).
3. **Construct Link State Packet (LSP):** Contains router ID, sequence number, neighbor list, and link costs.
4. **Distribute LSPs:** Flood LSPs reliably to all routers, avoiding duplicates.
5. **Compute Shortest Path:** Use **Dijkstraâ€™s algorithm** locally to find shortest paths from the router to all destinations. This forms a **sink tree**.

---
### Dijkstraâ€™s Algorithm
- Finds shortest paths from a source to all nodes using non-negative edge weights.
- Labels nodes with tentative distances, updating them as shorter paths are found.
- Nodes become **permanent** when their shortest path is determined.
- Iteratively examines nodes with the smallest tentative distance to update neighbors.

---

## iii. The Optimality Principle
- If router **J** lies on the optimal path from **I â†’ K**, then the optimal path from **J â†’ K** must follow the same route.
- Consequently, **all optimal routes** to a destination form a **sink tree** rooted at that destination.

---

## iv. Hierarchical Routing

Large networks require hierarchy to reduce memory and computation overhead.

- **Autonomous Systems (AS):** Networks and routers under one administration form an AS.
- **Two-Level Routing:**
  - **Intradomain (IGP):** Routing *within* an AS (e.g., RIP, OSPF, IS-IS).
  - **Interdomain (EGP):** Routing *between* ASes (e.g., **BGP**, a path vector protocol listing AS paths).

> OSPF supports hierarchy by splitting an AS into **areas** connected by a central **backbone (Area 0)**, so no single router stores the full AS topology.


### Hierarchical Routing and Autonomous Systems (AS)

The Internet is too large for a single routing protocol to handle efficiently. To manage this, the Network Layer organizes networks into a hierarchy of **Autonomous Systems (AS)**. An AS is a group of networks and routers under the authority of a single administrationâ€”think of it like an **ISP network**.

This structure leads to **two levels of routing**: intradomain (inside an AS) and interdomain (between ASes).

---

### i. Intradomain Routing (Interior Gateway Protocol, IGP)

**Intradomain routing** handles routing *within* a single AS. It is also called an **Interior Gateway Protocol**.

- **Goal:** Move packets efficiently from source to destination **inside the AS** without worrying about business policies or external agreements.
- **Protocols Used:**
  - **OSPF (Open Shortest Path First):** A link state protocol that computes shortest paths efficiently. It scales in large ASes by dividing the AS into **numbered areas**, all connected to a **backbone area (Area 0)**.
  - **RIP (Routing Information Protocol):** An older distance vector protocol. Works well in small networks but suffers from **slow convergence** and the **count-to-infinity problem** in large systems.

---

### ii. Interdomain Routing (Exterior Gateway Protocol, EGP)

**Interdomain routing** handles routing *between* different ASes. Also called an **Exterior Gateway Protocol**.

- **Goal:** Determine how packets flow **between ASes**, taking into account **policies, politics, and business arrangements** (e.g., transit agreements or peering).
- **Protocol Used:** All ASes use the **same interdomain protocol**. The standard for the Internet is **BGP (Border Gateway Protocol)**.

---

### iii.BGP and Path Vector Routing

**BGP** is a type of distance vector protocol, but unlike RIP or OSPF, it uses **Path Vector Routing**.

### How Path Vector Works
- **Speakers:** Each AS has one or more **speaker routers** representing the AS in exchanges with neighboring ASes.
- **Path Advertisement:** Instead of just sending a metric, BGP routers advertise the **entire AS path** that a route has traversed. Each path includes attributes giving detailed information about the route.
- **Updating Routes:** When a router receives a path advertisement, it checks the AS path and applies policies before updating its own routing table and forwarding the route to neighbors.
- **Benefits:** Path vector prevents routing loops between ASes and allows enforcement of business policies.

> BGP is the protocol that glues the Internet together by ensuring that every AS knows valid paths to other ASes, respecting policies and avoiding loops.


---

## 6.Network Layer Support Protocols â€“ ARP, ICMP, DHCP

The **Network Layer (Layer 3)** relies on the **Internet Protocol (IP)** for its core functionality. IP provides a **connectionless, best-effort service** for delivering packets (datagrams) from a source to a destination.  
Since IP itself is **unreliable** and doesnâ€™t handle flow control or detailed error reporting, several **supporting protocols** step in to handle these essential tasks, such as **address translation, error reporting, and dynamic host configuration**.  

The main supporting protocols are: **ARP (Address Resolution Protocol), ICMP (Internet Control Message Protocol), and DHCP (Dynamic Host Configuration Protocol)**.

---

### i. ARP (Address Resolution Protocol)

**ARP** dynamically maps a **logical IP address** to a **physical MAC address**, which is crucial because:

- IP uses **logical addresses** for end-to-end delivery.
- The Data Link Layer requires **physical addresses** to actually deliver frames on the local network.

### How ARP Works
1. **ARP Request (Broadcast):**  
   The sender knows the target IP but not the MAC. It broadcasts an ARP request to all devices on the local network, including the sender's IP/MAC and the target IP (MAC set to 0s).
2. **ARP Reply (Unicast):**  
   The intended recipient recognizes its IP and replies directly with its MAC address.
3. **Caching:**  
   The sender stores this mapping temporarily to avoid repeating the broadcast.

### Typical Use Cases
1. **Host â†” Host (Same Network):** Direct mapping of IP to MAC.
2. **Host â†” Host (Different Network):** IP maps to **next-hop router** MAC via routing table.
3. **Router â†” Router:** Next routerâ€™s IP is mapped to its MAC.
4. **Router â†” Host (Same Network):** Destination hostâ€™s IP mapped to its MAC.

### Proxy ARP
- The router answers ARP requests **on behalf of internal hosts** using its own MAC.
- Creates a **subnetting effect**, making the router appear as the host.
- Used in **Mobile IP**, where a home agent intercepts packets for a mobile host.

---

### ii. ICMP (Internet Control Message Protocol)

**ICMP** complements IP by **handling errors and diagnostics** since IP itself is unreliable. ICMP messages are sent inside **IP packets**.

### Types of ICMP Messages

#### A. Error-Reporting
Sent **back to the source** when a router or host encounters a problem.

| Message Type | Description |
|--------------|-------------|
| **Destination Unreachable** | Router cannot route or host cannot deliver; packet discarded. |
| **Time Exceeded** | TTL reached zero or fragment timeout; indicates loops or delays. |
| **Parameter Problem** | Header field missing or invalid. |
| **Source Quench** | Congested router warns sender to **slow down**. |
| **Redirection** | Router informs host to use a better path next time. |

#### B. Query / Diagnostic Messages
Help check network status or obtain information.

| Message Type | Description |
|--------------|-------------|
| **Echo Request/Reply** | `ping` utility; checks if host is reachable. |
| **Timestamp Request/Reply** | Measures **round-trip time** and helps sync clocks. |
| **Router Solicitation/Advertisement** | Finds nearby router IP addresses. |
| **Address-Mask Request/Reply** | Obtains subnet mask for the host IP. |

### ICMPv6 Notes
- In **IPv6**, ARP and IGMP functions are integrated into **ICMPv6**.
- **Source Quench** removed; congestion handled using IPv6 **flow label**.
- Added **Packet Too Big** message since IPv6 fragmentation is source-only.

---

### iii. DHCP (Dynamic Host Configuration Protocol)

**DHCP** is a **client-server protocol** that automates host configuration, primarily **IP address assignment**.  
It replaces older methods like RARP and BOOTP.

### How DHCP Works
1. **Discovery:** Host without IP broadcasts **DHCP DISCOVER**.
2. **Relay Agent:** If the DHCP server is remote, the local router forwards the request via **unicast**.
3. **Offer / Lease:** Server selects an IP from its pool and offers it to the host.
4. **Renewal:** Host requests lease renewal before expiration.

### Address Allocation Methods
- **Static Allocation:** DHCP assigns a fixed IP based on host MAC (like BOOTP).
- **Dynamic Allocation:** DHCP leases IPs from a pool for a limited time.

### Beyond IP Address
DHCP can also provide:
- Subnet mask
- Default gateway
- DNS server addresses



---

## 7. MPLS and Mobility

- **MPLS**: Routers use short labels instead of IP addresses for faster forwarding.  
- **Mobile IP**: Lets a device keep its IP while moving.  
  - Home Agent tunnels traffic to the deviceâ€™s temporary address.

---

## 8. Congestion & QoS

When too many packets hit the network, performance tanks.

### Tools to handle it:
- **Traffic Shaping**: Control bursty traffic at the source.
- **Packet Scheduling**: Decide which packet leaves first (e.g., FIFO, priority queues).
- **DiffServ**: Marks packets with priorities at the edge of the network, so routers treat them differently.

---

âœ… **Interview Tip**:  
When asked about the Network Layer, always connect theory to the **real-world Internet**:  
- IP addressing (IPv4 vs IPv6),  
- Routing protocols (RIP, OSPF, BGP),  
- Supporting protocols (ARP, ICMP, DHCP),  
- Concepts like fragmentation, NAT, and QoS.  
This shows you understand both **OSI theory** and **practical networking**.
