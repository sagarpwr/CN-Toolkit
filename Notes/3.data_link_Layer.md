# Data Link Layer (DLL) 

The **Data Link Layer** sits between the **Physical Layer (bit stream)** and the **Network Layer (packets)**. It receives raw bits from the Physical Layer, organizes them into **frames**, and delivers them reliably to the Network Layer. This layer is partitioned into two distinct, functionality-oriented sublayers: the **Logical Link Control (LLC)** sublayer and the **Medium Access Control (MAC)** sublayer. This division allows the functions related to link control (flow and error management) to be separated from the functions related to sharing a common channel (access control).

üìå **Data Unit:** **Frame** (Header + Payload + Trailer)



---

### 1. Medium Access Control (MAC) Sublayer

The **MAC sublayer** is the **lower part** of the Data Link Layer.

#### Introduction and Primary Function

The MAC sublayer is mainly responsible for resolving access to the **shared media**. This is particularly critical in networks where multiple stations share a single link, such as broadcast or multiaccess channels, including **wireless LANs**.

- **Channel Allocation Problem:** Determines **how the shared channel is allocated**‚Äîwhich device has control over the link at any given time.  
- **Location:** Part of the Data Link Layer that deals with sharing a channel between multiple computers.  
- **Protocols:** Defines the **specific access method** for each LAN. Examples include **CSMA/CD** for Ethernet and token passing for Token Ring.  
- **Framing Duties:** Handles **part of the framing function**, including fields for physical addressing like **Source Address (SA)** and **Destination Address (DA)**.


---

### 2. Logical Link Control (LLC) Sublayer

The **LLC sublayer** (IEEE 802.2) is the **upper part** of the Data Link Layer.

#### Introduction and Primary Function

The main job of the LLC is to provide a **single data link control protocol for all IEEE LANs**.

- **Hiding Differences:** LLC hides differences between the various 802 MAC protocols and makes them **indistinguishable to the Network Layer**.  
- **Data Link Control:** Manages **flow control**, **error control**, and part of **framing**:
  - **Flow Control:** Prevents a sender from sending data faster than the receiver can absorb.  
  - **Error Control:** Detects and handles errors (optional in many higher-layer protocols).  
- **Protocol Identification:** Identifies the higher-layer protocol (e.g., **IP**) carried within the frame payload.



---

# 1. Logical Link Control (LLC Sublayer ‚Äì Upper DLL)

---

## Data Link Layer: Framing

The **Network Layer (Layer 3)** sends **packets** to the Data Link Layer (DLL, Layer 2). The DLL organizes these packets into **frames** to ensure reliable and efficient transmission over the **Physical Layer (Layer 1)**.

---

### 1. What is Framing?

**Framing** is the process of breaking a continuous stream of bits from the physical layer into **discrete data units called frames**.

**Purpose:**

- Converts a raw bit stream into manageable frames.
- Encapsulates **Network Layer packets** for transmission.
- Adds **headers and trailers** to each frame (includes **checksums** for error detection).
- Enables **efficient flow and error control**‚Äîonly the damaged frame needs retransmission, not the whole message.

**Frame Components:**

- **Header:** Control info (addresses, protocol IDs, etc.)
- **Payload:** Contains the Network Layer packet.
- **Trailer:** Often includes **checksum** (CRC) for error detection.

---

### 2. Types of Framing

Frames can be **fixed-size** or **variable-size**.

#### A. Fixed-Size Frames

- All frames have the same length.
- No need for delimiters; size itself identifies the frame.
- **Example:** ATM networks use **cells** (fixed-size frames).

#### B. Variable-Size Frames

- Frames can have different lengths.
- Require **special methods** to indicate frame boundaries.

| Method | How it Works | Notes / Error Handling |
| ------ | ------------ | -------------------- |
| **Byte Count** | Header field specifies number of bytes in the frame. Receiver counts bytes. | Corruption of count causes **loss of synchronization**. Rarely used alone. |
| **Flag Bytes + Byte Stuffing** | Frame starts/ends with a special **flag byte**. If flag occurs in data, an **ESC byte** is inserted before it. | Receiver removes escape bytes. Used in **PPP**. |
| **Flag Bits + Bit Stuffing** | Uses special **bit pattern** (e.g., `01111110`) to mark start/end. If five consecutive 1s appear in data, a 0 is inserted. | Receiver removes stuffed bits. Ensures unambiguous frame boundaries. Used in **HDLC**. |
| **Physical Layer Coding Violations** | Uses **reserved signals or bit patterns** to mark frame boundaries. | Easy to detect, no stuffing needed. |

---
## Byte Stuffing & Bit Stuffing

Frames start and end with a special marker called a **flag** (like a ‚Äústart‚Äù and ‚Äúend‚Äù sign).
But what if the data itself contains the same marker? The receiver might get confused and think the frame ended early.
This is where **Byte Stuffing** and **Bit Stuffing** come in-they prevent this confusion.

---

### 1. Byte Stuffing (Character-Oriented)

- **Purpose:** Prevent confusion when the data contains the same byte as the frame delimiter (flag byte).  
- **Mechanism:** Insert a special **escape byte (ESC)** before any flag byte inside the data.
- **Operation:**
  - **Sender:** Adds ESC before each flag byte in the data.
  - **Receiver:** Removes ESC to recover original data.
- **Example:**

| Data | Byte-Stuffed Data |
|------|-----------------|
| `A 0x7E B` | `A ESC 0x7E B` |

- **Used in:** PPP (Point-to-Point Protocol) and other byte-oriented protocols.

---

### 2. Bit Stuffing (Bit-Oriented)

- **Purpose:** Prevent confusion when the data contains the same **bit pattern** as the frame delimiter (e.g., `01111110`).  
- **Mechanism:** Insert a **0 bit** after five consecutive 1s in the data stream.
- **Operation:**
  - **Sender:** Automatically inserts the extra 0 bit during transmission.
  - **Receiver:** Removes the extra 0 bit to reconstruct the original data.
- **Example:**

| Data Bits | Bit-Stuffed Data |
|-----------|-----------------|
| `111110111` | `1111100 111` |

- **Used in:** HDLC (High-Level Data Link Control) and bit-oriented protocols.

---

## 3. Key Comparison

| Feature | Byte Stuffing | Bit Stuffing |
|---------|---------------|--------------|
| Level | Byte | Bit |
| Special Marker | Flag Byte | Flag Bit Pattern |
| Mechanism | Insert ESC before flag byte | Insert 0 after 5 consecutive 1s |
| Common Protocols | PPP, SLIP | HDLC |

---

**Summary:**  

- **Byte Stuffing** adds an escape byte to protect special bytes.  
- **Bit Stuffing** adds a 0 bit to protect special bit patterns.  

Both techniques ensure that **frame boundaries are always correctly recognized** by the receiver.

---
### 3. Combination Methods

Protocols often combine methods for reliability:

- **Ethernet & 802.11:** Use a **preamble** for synchronization followed by a **length field** to locate frame end.
- Improves clock sync and frame boundary detection.

---

### 4. Framing in Common Protocols

| Protocol | Type | Framing Method |
| -------- | ---- | -------------- |
| **HDLC** | Bit-oriented | Bit stuffing |
| **PPP** | Byte-oriented | Byte stuffing, HDLC flag byte `0x7E` |
| **T1 Carrier** | Fixed-size | 192 data bits + 1 control bit for sync |
| **SONET** | Fixed-size | 810-byte frames; 2-byte alignment pattern for sync |

---

**Key Takeaways:**

- Framing allows **reliable and structured transmission** over physical links.
- **Error detection** is integrated via **trailer checksums**.
- **Synchronization** is crucial‚Äîachieved via preambles, flags, or reserved signals.
- Different methods are chosen based on **LAN/WAN requirements** and **protocol type**.


---

## Error Control in the Data Link Layer (DLL)

**Error control** ensures that data sent between two directly connected machines arrives **correctly and completely**. The Data Link Layer (Layer 2) transforms a **raw, unreliable physical link** into a communication line that **appears error-free**.

---

### Why Error Control is Needed

- Physical links can introduce **bit errors** due to noise or interference.
- Without error control, **incorrect data** may reach upper layers.
- Ensures **reliability** and **efficiency** by retransmitting only corrupted frames.

---

### How Error Control Works

### 1. Adding Redundancy
- Extra bits are added to each frame to detect or correct errors.
- Common techniques:
  - **Checksums**
  - **Parity bits**
  - **Cyclic Redundancy Check (CRC)**

---

### 2. Main Strategies

#### A. Error Detection and Retransmission (ARQ)
- Detects errors and requests retransmission.
- Efficient for mostly reliable channels.
- Mechanism:
  - Receiver sends **ACK** (acknowledgement) if frame is correct, **NAK** if error detected.
  - Sender uses **timers**; retransmits frame if no ACK received.
  - **Sequence numbers** prevent duplicates.
  - **Sliding window protocols:** Go-Back-N (GBN), Selective Repeat (SR).

#### B. Error Correction (FEC)
- Includes enough redundancy to **correct errors automatically**.
- Useful for noisy channels (e.g., wireless networks).


---

### 5. DLL vs Transport Layer Error Checking

| Layer | Scope | Code Used | Purpose |
|-------|-------|-----------|---------|
| **Data Link Layer** | Single link (hop-to-hop) | CRC, simple checksums | Detect/correct errors between two adjacent machines |
| **Transport Layer** | End-to-end (source to destination) | TCP checksum | Ensure message correctness across the **entire network path** |

---

#### Key Takeaways
- DLL error control **protects frames** on noisy links.
- **ARQ** = detect errors + request retransmission.
- **FEC** = detect errors + correct automatically.
- **Sequence numbers, timers, and checksums** are essential.
- DLL error control improves performance; transport layer checks ensure **end-to-end correctness**.

---
## Checksum in the Data Link Layer (DLL)

A **checksum** is a simple form of **error-detecting code** used by the Data Link Layer (DLL) to ensure that a **frame is received correctly** over a physical link. The checksum adds **redundant information** to the frame, allowing the receiver to detect corrupted data.

---

### Purpose of DLL Checksums

- Detect **transmission errors** in frames between two adjacent nodes.
- Improve **reliability** of data transfer over noisy or unreliable links.
- Often implemented alongside **other error control mechanisms** like **ARQ**.

---

### General Checksum Mechanism

1. **Sender Side:**
   - Compute a checksum based on the **data bits of the frame**.
   - A common method: **sum all data words** and optionally take the **complement**.
   - Append the checksum to the frame before sending.

2. **Receiver Side:**
   - Add all received data words **including the checksum**.
   - If the sum is **0**, the frame is assumed correct.
   - If non-zero, the frame is **corrupted** and typically **discarded**.

---

### Advantages of DLL Checksums

- **Lightweight and fast** for hop-to-hop verification.
- Enables **early detection** of corrupted frames before they reach higher layers.
- Works seamlessly with **ARQ protocols** for retransmission.

---

### Limitations

- Simple checksums may **miss certain error patterns** (e.g., two bits swapped).
- Stronger codes like **CRC** are preferred for robust error detection.
- DLL checksums protect frames only **link-by-link**, not end-to-end.
- End-to-end integrity is ensured by higher layers (Transport Layer checksums).

---

### Summary

In the Data Link Layer:

- **Checksum = simple error-detecting code**.
- Ensures **frame integrity** over a single link.
- Usually combined with **ACK/NAK and retransmission mechanisms**.
- For stronger protection, **CRC is used** in modern protocols like Ethernet and PPP.

---
## Parity, Hamming Distance, and Hamming Codes (Error Detection & Correction)

These techniques are key tools for **Error Detection and Correction** at the **Data Link Layer (DLL)**. They add **redundant bits** to transmitted data so that the receiver can detect or even correct errors.

---

### 1. Hamming Distance

- **Definition:** The **Hamming distance** between two codewords is the **number of bit positions where they differ**.
- **Significance:** Determines error-detection and correction capabilities:
  - To **detect t errors**, minimum distance $d_{\min} = t + 1$.
  - To **correct t errors**, minimum distance $d_{\min} = 2t + 1$.
- **Calculation:** XOR the two codewords and count the 1s.
  
**Example:**
Codeword1: 1011001
Codeword2: 1001101
XOR: 0010100 ‚Üí Hamming distance = 2

> Interpretation: 2 single-bit flips are needed to transform one codeword into the other.

---

### 2. Parity

#### Simple Parity-Check Code

- **Mechanism:** Add **1 parity bit** to a k-bit dataword, forming an n-bit codeword ($n = k+1$).  
- Ensures total number of 1s is **even (even parity)** or **odd (odd parity)**.
- **Detection Capability:**  
  - Hamming distance $d_{\min} = 2$  
  - Can reliably detect **single-bit errors** or **any odd number of errors**.
- **Limitation:** Cannot detect **even number of errors**.

**Example:**

- Dataword: `1011` (4 bits)  
- Even parity: Number of 1s = 3 (odd), so parity bit = 1 ‚Üí Codeword = `10111`  
- If 1 bit flips during transmission: `10011` ‚Üí parity check fails ‚Üí error detected.

#### Parity for Error Correction (Erasures)

- If the **position of the missing bit is known**, parity can reconstruct the lost data.
- **Example:**  
  - Data packets: A = 1010, B = 1100, C = 0110, D = 1001  
  - Parity packet P = A ‚äï B ‚äï C ‚äï D = 0001  
  - If packet B is lost, receiver can compute:  
    `B = P ‚äï A ‚äï C ‚äï D = 0001 ‚äï 1010 ‚äï 0110 ‚äï 1001 = 1100`

---

### 3. Hamming Codes

**Hamming codes** are **linear, systematic block codes** for **single-bit error correction**.

#### Structure & Encoding

1. **Bit Numbering:** Start from 1.
2. **Check Bits:** Positions = powers of 2 (1, 2, 4, 8, ‚Ä¶)
3. **Data Bits:** All other positions.
4. **Parity Rule:** Each check bit enforces **even parity** over specific bits.
5. **Check Assignment:** A data bit at position k is checked by check bits corresponding to powers of 2 in its binary form.

**Example (7,4 Hamming Code):**

- 4 data bits: D1 D2 D3 D4 = `1011`
- Positions: 1 2 3 4 5 6 7 ‚Üí C1 C2 D1 C4 D2 D3 D4 (C = check bit)
- Compute check bits (even parity):
  - C1 checks bits 1,3,5,7 ‚Üí C1 = D1 ‚äï D2 ‚äï D4 = 1 ‚äï 0 ‚äï 1 = 0 (even parity)
  - C2 checks bits 2,3,6,7 ‚Üí C2 = D1 ‚äï D3 ‚äï D4 = 1 ‚äï 1 ‚äï 1 = 1
  - C4 checks bits 4,5,6,7 ‚Üí C4 = D2 ‚äï D3 ‚äï D4 = 0 ‚äï 1 ‚äï 1 = 0
- **Final codeword:** `C1 C2 D1 C4 D2 D3 D4 = 0 1 1 0 0 1 1`  

#### Error Detection & Correction

- **Minimum Hamming distance:** $d_{\min} = 3$  
  ‚Üí Can correct **1 error** or detect **2 errors**.
- **Decoding Process:**
  1. Compute received check bits.
  2. Generate **syndrome**.
  3. Syndrome value indicates **error position**.
  4. Flip the erroneous bit to correct.

**Example of Correction:**

- Received: `0 1 1 0 1 1 1` (bit 5 flipped)  
- Syndrome = 5 ‚Üí flip bit 5 ‚Üí original codeword restored.

#### Usage

- **Memory modules** (ECC RAM), **satellite communication**, **data storage**.
- Networks usually use **stronger codes** like **Convolutional**, **Reed-Solomon**, or **CRC** for error detection and retransmission.

---
### Cyclic Redundancy Check (CRC)

The **Cyclic Redundancy Check (CRC)** is a **strong error-detecting code** widely used at the **Data Link Layer**. It is more powerful than simple parity or checksums and is implemented in hardware for fast detection.

---

### Core Concept: Treating Bits as Polynomials

- A data frame of **k bits** is treated as a polynomial $M(x)$ of degree $k-1$, with **coefficients 0 or 1**.
- Operations are done using **modulo 2 arithmetic (XOR)**.
- A **generator polynomial** $G(x)$ is agreed upon by both sender and receiver. Its high and low bits must be 1.

---

### CRC Computation (Sender Side)

1. **Append Zeros:** Let $r$ = degree of $G(x)$. Append $r$ zeros to the $m$-bit frame ‚Üí $x^r M(x)$.
2. **Modulo 2 Division:** Divide $x^r M(x)$ by $G(x)$ using XOR.
3. **Subtract Remainder:** XOR the remainder with $x^r M(x)$ to get the **checksummed frame $T(x)$**.
4. **Transmit Frame:** Send $T(x)$; it is divisible by $G(x)$.

**Example:**

- Data: `1101` (4 bits), Generator `1011` (degree 3)  
- Append 3 zeros: `1101000`  
- Divide `1101000` by `1011` using XOR ‚Üí remainder `011`  
- Transmitted frame: `1101011` (original + CRC bits)

---

### CRC Verification (Receiver Side)

1. Receive the checksummed frame.
2. Divide it by the same $G(x)$ using modulo 2 division (XOR).
3. **Check Remainder:**
   - `0` ‚Üí no errors detected ‚Üí accept frame
   - Non-zero ‚Üí error detected ‚Üí discard frame

---

### Implementation & Usage

- **Hardware Friendly:** Easily implemented using **shift registers**.
- **Standards:** Used in **Ethernet, 802.11, PPP, SONET, AAL5 (ATM)**.
- **Frame Field:** Often called **Frame Check Sequence (FCS)**; usually 2 or 4 bytes.
- **Speed:** Efficient for real-time transmission due to hardware support.

---

### Error Detection Guarantees

- **Single-bit errors:** Always detected.
- **Odd-numbered errors:** Detected if $G(x)$ divisible by $(x+1)$.
- **Double-bit errors:** Detected if $G(x)$ does not divide $x^k + 1$ for small k.
- **Burst errors:** Excellent performance; e.g., CRC-32 detects all bursts ‚â§ 32 bits.

---

**Key Advantage:** CRC provides strong, fast, and hardware-efficient detection of transmission errors, making it ideal for the Data Link Layer.

---

## Flow Control in the Data Link Layer (DLL)

Flow control is one of the **core responsibilities** of the Data Link Layer.  
Its goal is simple yet critical: **don‚Äôt let a fast sender drown a slow receiver**.

---

### Why Flow Control is Needed?

- **Receiver‚Äôs Limitation:** Every receiver has limited processing speed and a finite **buffer (memory)** to temporarily hold incoming frames.  
- **Risk:** If the sender keeps transmitting without restrictions, the buffer **overflows** ‚Üí frames are lost, and retransmission becomes necessary.  
- **Solution:** Flow control acts like a **traffic signal**: it regulates when the sender can transmit and when it must wait.


---

### 1. Important Terms in Flow Control

#### **Sender Window**
- Defines the set of **sequence numbers the sender can transmit**.
- Frames already sent or ready to send but unacknowledged are **kept in buffer**.
- **Window slides forward** when acknowledgements (ACKs) arrive, freeing buffer space.

#### **Receiver Window**
- Defines the **sequence numbers receiver is allowed to accept**.
- Frames **within window** are accepted; frames outside are discarded.
- Ensures **in-order delivery** to the Network Layer.

#### **Sequence Numbers**
- Assign a unique **number to each frame** to track delivery.
- Crucial for **distinguishing new frames from duplicates**, handling **retransmissions**, and **maintaining in-order delivery**.
- Typically modulo `2^m`, where `m` is number of bits in sequence number field.

---



### 2. Key Delays in Data Transmission

#### **Transmission Delay (Tt)**

T_t = Frame Size / Link Bandwidth 
- Time to **push all bits of a frame onto the link**.
- Larger frames or slower links ‚Üí higher Tt.

#### **Propagation Delay (Tp)**

T_p = Distance /Propagation Speed 

- Time for a **bit to travel from sender to receiver**.
- High on long-distance links (satellite, intercontinental fiber).

#### **Queuing Delay**
- Time a frame waits in **buffers or queues** before transmission.
- Depends on network congestion and receiver‚Äôs processing.

#### **Processing Delay**
- Time for **header, checksum, and protocol handling** at sender/receiver.
- Usually small but notable for high-speed links.

---

### 4. Utilization and Efficiency

#### **Stop-and-Wait Utilization**

U = T_t/(T_t + 2T_p)

- `U` ‚Üí fraction of time the sender is actively transmitting.
- Low for **long links** because sender waits for ACK.

#### **Sliding Window Advantage**
- Multiple frames in flight hide **propagation delay**.
- Efficiency improves with **larger sender windows**:
  Optimal Window Size = {Bandwidth-Delay Product (BDP)} = {Bandwidth} * {Round-Trip Time}


---


‚ö° **Quick Mnemonic:**  
**‚ÄúSeq, Window, Slide, ACK, Delay‚Äù** ‚Üí Sequence numbers + window size + sliding mechanism + acknowledgements + delays = Flow control mastery!



### How Flow Control Works in DLL?

Flow control = **rules for sender ‚Üí wait for receiver‚Äôs permission before sending more data**.  
It‚Äôs mostly implemented via **feedback-based schemes** (receiver explicitly or implicitly signals its state).

## 1. Stop-and-Wait Protocol (Data Link Layer)


The **Stop-and-Wait Protocol** is a simple **flow control** mechanism at the Data Link Layer.  
It ensures that a **fast sender does not overwhelm a slow receiver** by enforcing strict turn-taking with acknowledgements.

---

### 1. Core Idea
- Send **one frame ‚Üí wait for ACK ‚Üí send next frame**.
- Works like a **ping-pong game**: the sender sends, then waits until the receiver replies.
- Guarantees flow control because the sender is **blocked until ACK arrives**.

---

### 2. Working Mechanism

#### Sender:
1. Fetches a packet from the **Network Layer**.
2. Constructs a **frame** and transmits it.
3. Waits until an **ACK** arrives.
4. On ACK ‚Üí repeats the cycle.

#### Receiver:
1. Receives the frame, extracts the data.
2. Passes data upward to its **Network Layer**.
3. Sends an **ACK frame** back to the sender.
4. Waits for the next frame.

‚ö° Data flows in one direction, ACKs in the reverse ‚Üí **half-duplex communication**.

---

### 3. Variants

#### ‚úÖ Stop-and-Wait (Noiseless) ‚Äî *Protocol 2*
- Assumes error-free channel.
- Very simple: **one data frame + one ACK frame** exchange.

#### ‚úÖ Stop-and-Wait ARQ (Noisy) ‚Äî *Protocol 3 / PAR*
Used in real networks where errors occur.
1. **Sequence Numbers (0,1 modulo-2):** Distinguish new frames from retransmissions.
2. **Timers:** Sender sets a timer for every frame sent.
   - If timeout ‚Üí retransmit.
3. **Retransmission Rule:** Sender keeps a copy of the frame until its ACK is received.

---

### 4. Efficiency

Efficiency (U) = Transmission Time / (Transmission Time + 2 √ó Propagation Delay)

- Efficiency falls sharply when **propagation delay >> transmission time**.  
- Example: Satellite link ‚Üí channel mostly idle.

---

### 5. Relation to Sliding Window
- **Stop-and-Wait = Sliding Window with window size = 1.**
- Stop-and-Wait ARQ = special case of **Go-Back-N ARQ** with window size = 1.

---

### 6. Strengths & Weaknesses

#### üëç Strengths:
- Simple to implement.
- Provides flow control.
- Suitable for **low-speed, low-delay links**.

#### üëé Weaknesses:
- **Inefficient** for long-delay or high-bandwidth networks.
- Sender idle most of the time.

---


### üîë Analogy
Imagine sending WhatsApp voice notes:  
- You record ‚Üí send ‚Üí **wait for ‚ÄúGot it‚Äù reply** ‚Üí then send next one.  
That‚Äôs **Stop-and-Wait**.
*Cons:** Wastes capacity on long-delay links (since channel stays idle during wait).

---

## Sliding Window Protocols (Data Link Layer)

The **Sliding Window Protocol** is a class of **bidirectional protocols** that integrate **error control** and **flow control**.  
They improve transmission efficiency over links with high bandwidth √ó delay product.

---

### üîë Core Concept: Windows
At any instant, both **sender** and **receiver** maintain a **window**:

### Sender‚Äôs Window
- Defines the range of frames the sender is allowed to transmit.  
- Frames inside the window = **sent but not yet ACKed** ‚Üí must be kept in memory.  
- **ACK arrival** slides the window forward, freeing buffer space.  
- Enables **pipelining** (multiple frames in transit before ACK).

### Receiver‚Äôs Window
- Defines the range of frames the receiver is willing to accept.  
- Frames **within window** ‚Üí accepted and buffered.  
- Frames **outside window** ‚Üí discarded.  
- Frames must be delivered to the **Network Layer in-order**.

---

### üöÄ Why Sliding Window?
Unlike **Stop-and-Wait**, sliding windows allow:
- **Multiple outstanding frames** (pipeline).  
- **Better efficiency** on long/fat links.  
- **Joint flow + error control**.

---

### üõ†Ô∏è Types of Sliding Window Protocols

### 1. Go-Back-N (GBN ARQ)


The **Go-Back-N Automatic Repeat reQuest (GBN ARQ)** protocol is a **sliding window protocol** used in the Data Link Layer (DLL) for **noisy channels**.  
It improves efficiency by allowing multiple frames to be **outstanding** (in transit) before receiving acknowledgements.

---

### 1Ô∏è‚É£ Mechanism and Sliding Window


#### Sender Window
- **Constraint:** `Send Window ‚â§ 2^m ‚Äì 1`
- **Frames in window:** Sent but unACKed ‚Üí must be buffered for possible retransmission.
- **Sliding:** Moves forward when **valid ACK** is received.
- **Outstanding frames:** Frames sent but not yet ACKed.

#### Receiver Window
- **Size:** Always `1`.
- **Variable:** `Rn` (receiver, next frame expected).
- **Operation:** Accepts only the frame with sequence = `Rn`.  
  Any out-of-order frames are **discarded**.

---

### 2Ô∏è‚É£ Error Handling ‚Üí Why ‚ÄúGo-Back-N‚Äù?

- If a frame is **lost/corrupted**, the receiver:
  - Discards the erroneous frame **and all following frames**.  
  - Sends no ACKs for them.  
- Sender keeps transmitting until:
  - **Timer expires** for the oldest unACKed frame.  
  - Sender then **goes back** to that frame and **resends all outstanding frames in order**.  

‚ö° Example: If frame 4 is lost ‚Üí frames 5, 6, 7‚Ä¶ are discarded ‚Üí sender retransmits 4, 5, 6, 7‚Ä¶

---

### 3Ô∏è‚É£ Acknowledgements & Flow Control

- **Cumulative ACKs:**  
  ACK for frame `n` also implies ACK for all frames before it (`n-1, n-2, ‚Ä¶`).  
  ‚Üí Handles lost/garbled ACKs automatically.
- **Flow Control:**  
  Enforced by window size. If the **send window is full**, the sender stops asking the Network Layer for more packets.

---

## ‚ú® Key Insights
- Stop-and-Wait = GBN with window size **1**.  
- GBN is **simpler** than Selective Repeat (no out-of-order buffering).  
- But on noisy channels ‚Üí **bandwidth is wasted** by resending many correct frames.


---

### 2. Selective Repeat (SR) ARQ Protocol
 

The **Selective Repeat Automatic Repeat reQuest (SR ARQ)** is a **highly efficient sliding window protocol** in the **Data Link Layer (DLL)**, designed for **noisy communication links**. Unlike Go-Back-N (GBN) ARQ, SR ARQ minimizes unnecessary retransmissions by resending only the corrupted or lost frames.

---

### 1. Purpose and Efficiency

- **Goal:** Avoid unnecessary retransmissions; resend **only damaged frames**.
- **Preferred Environment:** **Noisy links**, where GBN would waste bandwidth by resending multiple frames unnecessarily.
- **Efficiency:** More efficient than GBN in noisy environments due to selective retransmission.

---

### 2. Window Mechanism

**Sender Window:**

- Defines the **range of frames that can be sent**.
- Sender must **buffer all outstanding frames** until they are acknowledged.

**Receiver Window (Key Difference from GBN):**

- Allows **buffering of out-of-order frames**.
- Receiver window size > 1.
- Frames are stored in a buffer until missing frames arrive.

**Sequence Numbers:**

- Maximum sequence number space: \(2^m\), where \(m\) = number of bits used.
- Integrated flow and error control mechanisms.

---

## 3. Error Handling and Retransmission

- **Buffering Out-of-Order Frames:** Subsequent frames are accepted and stored even if a prior frame is lost.
- **Selective Retransmission:** Only the **lost or damaged frame** is resent.
- **Negative Acknowledgement (NAK) / Selective Reject (SREJ):** Receiver can request retransmission of a specific frame.
- **Delivery to Network Layer:** Frames delivered **only when a contiguous block of frames is complete**.

---

### 4. Window Size Constraint

To prevent confusion between **new frames and retransmissions**:
Window size = 2^{m-1}

- Applies to **both sender and receiver windows**.
- Ensures correct interpretation of sequence numbers even if acknowledgements are lost.

---

### 5. Implementation Complexity

- **Receiver Complexity:** Must maintain multiple buffers for out-of-order frames.
- **Sender Complexity:** Needs **multiple timers**, one for each frame in the window, to handle selective retransmissions.

---

### 6. Connection to Transport Layer (SACK)

Although SR ARQ is a DLL concept, the **selective acknowledgment mechanism** is also used in the Transport Layer:

- **SCTP:** Uses **Selective ACKnowledgement (SACK)** chunks to inform sender of buffer state.
- **TCP:** Uses **SACK option** to indicate **ranges of received sequence numbers**, helping the sender retransmit only missing data.

---

**Key Takeaways for Revision & Viva:**

1. SR ARQ = **efficient, selective retransmission**.
2. Receiver window > 1; buffers **out-of-order frames**.
3. Window size ‚â§ \(2^{m-1}\) to avoid confusion.
4. More **complex** than GBN; better for **noisy links**.
5. Forms the **basis for SACK** in Transport Layer protocols.

---

## üåü Quick Comparisons
| Protocol        | Sender Window | Receiver Window | Error Handling                  | Efficiency        |
|-----------------|---------------|-----------------|---------------------------------|-------------------|
| Stop-and-Wait   | 1             | 1               | Retransmit single frame         | Low (idle time)   |
| Go-Back-N (GBN) | ‚â§ 2^m ‚Äì 1     | 1               | Retransmit lost + later frames  | Medium (wasteful) |
| Selective Repeat (SR) | ‚â§ 2^(m-1) | ‚â§ 2^(m-1) | Retransmit only missing frame   | High (efficient)  |

---

## Flow Control vs Congestion Control

They sound similar but solve **different problems**:

- **Flow Control (Local Issue):**
  - Focus: Sender ‚Üî Receiver pair.  
  - Prevents **receiver buffer overflow**.  
  - E.g., Stop-and-Wait, Sliding Window.  

- **Congestion Control (Global Issue):**
  - Focus: The **network as a whole**.  
  - Prevents **routers/links from being overloaded**.  
  - E.g., TCP Congestion Avoidance, RED (Random Early Detection).

> **Flow control = ‚ÄúDon‚Äôt flood your friend‚Äôs inbox.‚Äù**  
> **Congestion control = ‚ÄúDon‚Äôt crash Gmail servers with too many emails at once.‚Äù**

---

## Quick VIVA / Interview Pointers üé§

- **Q:** What is flow control in DLL?  
  **A:** A mechanism to prevent a fast sender from overwhelming a slow receiver, by regulating unacknowledged frames using ACKs and window size.

- **Q:** Difference between Stop-and-Wait and Sliding Window?  
  **A:** Stop-and-Wait = send 1 frame, wait for ACK. Sliding Window = send multiple frames (up to window size), ACKs slide the window forward.

- **Q:** Flow control vs Congestion control?  
  **A:** Flow control = sender-receiver issue (buffer). Congestion control = whole-network issue (capacity).

- **Q:** Is flow control only in DLL?  
  **A:** No. DLL handles **link-level flow control**, while **Transport Layer** handles **end-to-end flow control**.

---



---

## 2. Medium Access Control (MAC Sublayer ‚Äì Lower DLL)

Handles **channel sharing** in broadcast networks (e.g., LANs).  
Controls **who transmits when** and uses **physical addresses**.

---

### Physical Addressing
- Every NIC has a **unique 48-bit MAC address** (e.g., `3C-95-09-4B-32-1A`).  
- Used for **hop-to-hop delivery** inside a LAN.  
- Changes at each hop (router).  
- Switches and bridges forward frames using **MAC tables**.

---

### Random Access Protocols
All stations compete for channel ‚Üí collisions possible.

- **ALOHA:**  
  - Send anytime. Collisions waste channel.  
  - **Slotted ALOHA:** Restricts to time slots, improving efficiency.  

- **CSMA (Carrier Sense Multiple Access):**  
  - Station senses channel before sending.  

  - **CSMA/CD (Collision Detection):**  
    - Used in classic Ethernet (IEEE 802.3).  
    - If collision detected ‚Üí stop, send jamming signal, wait (binary exponential backoff), retry.  
    - Requires full-duplex (hard in wireless).  

  - **CSMA/CA (Collision Avoidance):**  
    - Used in Wi-Fi (IEEE 802.11).  
    - Avoids collisions by waiting (IFS) + using **NAV timers**.  
    - Handles **Hidden Terminal Problem**:  
      - **RTS/CTS (Request to Send / Clear to Send):** handshake before sending data.  

---

### Channelization Protocols
- **FDMA:** Bandwidth divided into frequency slots.  
- **TDMA:** Bandwidth divided into time slots.  
- **CDMA:** Stations use orthogonal codes to share channel simultaneously.  

---

### Comparison: CSMA/CD vs CSMA/CA

| Feature | CSMA/CD (Ethernet) | CSMA/CA (Wi-Fi) |
|---------|--------------------|-----------------|
| Medium  | Wired LAN          | Wireless LAN    |
| Collision Handling | Detects collision, stops transmission | Tries to avoid collisions beforehand |
| Mechanism | Sense ‚Üí Transmit ‚Üí Detect collision | Sense ‚Üí Wait (IFS) ‚Üí RTS/CTS ‚Üí Transmit |
| Efficiency | High in low-collision networks | Better for noisy/wireless networks |
| Used In | IEEE 802.3 Ethernet | IEEE 802.11 Wi-Fi |

---

## Summary of DLL Structure (IEEE 802)

| Sublayer | Role | Key Concepts |
|----------|------|--------------|
| **LLC** (Upper DLL) | Framing, Flow & Error Control | Frames, Checksum, CRC, ARQ, GBN, SR |
| **MAC** (Lower DLL) | Media Access & Addressing | MAC Address, ALOHA, CSMA/CD, CSMA/CA, RTS/CTS |
