# Data Link Layer (DLL) 

The **Data Link Layer** sits between the **Physical Layer (bit stream)** and the **Network Layer (packets)**. It receives raw bits from the Physical Layer, organizes them into **frames**, and delivers them reliably to the Network Layer. This layer is partitioned into two distinct, functionality-oriented sublayers: the **Logical Link Control (LLC)** sublayer and the **Medium Access Control (MAC)** sublayer. This division allows the functions related to link control (flow and error management) to be separated from the functions related to sharing a common channel (access control).

üìå **Data Unit:** **Frame** (Header + Payload + Trailer)



---

### 1. Medium Access Control (MAC) Sublayer

The **MAC sublayer** is the **lower part** of the Data Link Layer.

#### Introduction and Primary Function

The MAC sublayer is mainly responsible for resolving access to the **shared media**. This is particularly critical in networks where multiple stations share a single link, such as broadcast or multiaccess channels, including **wireless LANs**.

- **Channel Allocation Problem:** Determines **how the shared channel is allocated**‚Äîwhich device has control over the link at any given time.  
- **Location:** Part of the Data Link Layer that deals with sharing a channel between multiple computers.  
- **Protocols:** Defines the **specific access method** for each LAN. Examples include **CSMA/CD** for Ethernet and token passing for Token Ring.  
- **Framing Duties:** Handles **part of the framing function**, including fields for physical addressing like **Source Address (SA)** and **Destination Address (DA)**.


---

### 2. Logical Link Control (LLC) Sublayer

The **LLC sublayer** (IEEE 802.2) is the **upper part** of the Data Link Layer.

#### Introduction and Primary Function

The main job of the LLC is to provide a **single data link control protocol for all IEEE LANs**.

- **Hiding Differences:** LLC hides differences between the various 802 MAC protocols and makes them **indistinguishable to the Network Layer**.  
- **Data Link Control:** Manages **flow control**, **error control**, and part of **framing**:
  - **Flow Control:** Prevents a sender from sending data faster than the receiver can absorb.  
  - **Error Control:** Detects and handles errors (optional in many higher-layer protocols).  
- **Protocol Identification:** Identifies the higher-layer protocol (e.g., **IP**) carried within the frame payload.



---

# 1. Logical Link Control (LLC Sublayer ‚Äì Upper DLL)

---

## Data Link Layer: Framing

The **Network Layer (Layer 3)** sends **packets** to the Data Link Layer (DLL, Layer 2). The DLL organizes these packets into **frames** to ensure reliable and efficient transmission over the **Physical Layer (Layer 1)**.

---

### 1. What is Framing?

**Framing** is the process of breaking a continuous stream of bits from the physical layer into **discrete data units called frames**.

**Purpose:**

- Converts a raw bit stream into manageable frames.
- Encapsulates **Network Layer packets** for transmission.
- Adds **headers and trailers** to each frame (includes **checksums** for error detection).
- Enables **efficient flow and error control**‚Äîonly the damaged frame needs retransmission, not the whole message.

**Frame Components:**

- **Header:** Control info (addresses, protocol IDs, etc.)
- **Payload:** Contains the Network Layer packet.
- **Trailer:** Often includes **checksum** (CRC) for error detection.

---

### 2. Types of Framing

Frames can be **fixed-size** or **variable-size**.

#### A. Fixed-Size Frames

- All frames have the same length.
- No need for delimiters; size itself identifies the frame.
- **Example:** ATM networks use **cells** (fixed-size frames).

#### B. Variable-Size Frames

- Frames can have different lengths.
- Require **special methods** to indicate frame boundaries.

| Method | How it Works | Notes / Error Handling |
| ------ | ------------ | -------------------- |
| **Byte Count** | Header field specifies number of bytes in the frame. Receiver counts bytes. | Corruption of count causes **loss of synchronization**. Rarely used alone. |
| **Flag Bytes + Byte Stuffing** | Frame starts/ends with a special **flag byte**. If flag occurs in data, an **ESC byte** is inserted before it. | Receiver removes escape bytes. Used in **PPP**. |
| **Flag Bits + Bit Stuffing** | Uses special **bit pattern** (e.g., `01111110`) to mark start/end. If five consecutive 1s appear in data, a 0 is inserted. | Receiver removes stuffed bits. Ensures unambiguous frame boundaries. Used in **HDLC**. |
| **Physical Layer Coding Violations** | Uses **reserved signals or bit patterns** to mark frame boundaries. | Easy to detect, no stuffing needed. |

---
## Byte Stuffing & Bit Stuffing

Frames start and end with a special marker called a **flag** (like a ‚Äústart‚Äù and ‚Äúend‚Äù sign).
But what if the data itself contains the same marker? The receiver might get confused and think the frame ended early.
This is where **Byte Stuffing** and **Bit Stuffing** come in-they prevent this confusion.

---

### 1. Byte Stuffing (Character-Oriented)

- **Purpose:** Prevent confusion when the data contains the same byte as the frame delimiter (flag byte).  
- **Mechanism:** Insert a special **escape byte (ESC)** before any flag byte inside the data.
- **Operation:**
  - **Sender:** Adds ESC before each flag byte in the data.
  - **Receiver:** Removes ESC to recover original data.
- **Example:**

| Data | Byte-Stuffed Data |
|------|-----------------|
| `A 0x7E B` | `A ESC 0x7E B` |

- **Used in:** PPP (Point-to-Point Protocol) and other byte-oriented protocols.

---

### 2. Bit Stuffing (Bit-Oriented)

- **Purpose:** Prevent confusion when the data contains the same **bit pattern** as the frame delimiter (e.g., `01111110`).  
- **Mechanism:** Insert a **0 bit** after five consecutive 1s in the data stream.
- **Operation:**
  - **Sender:** Automatically inserts the extra 0 bit during transmission.
  - **Receiver:** Removes the extra 0 bit to reconstruct the original data.
- **Example:**

| Data Bits | Bit-Stuffed Data |
|-----------|-----------------|
| `111110111` | `1111100 111` |

- **Used in:** HDLC (High-Level Data Link Control) and bit-oriented protocols.

---

## 3. Key Comparison

| Feature | Byte Stuffing | Bit Stuffing |
|---------|---------------|--------------|
| Level | Byte | Bit |
| Special Marker | Flag Byte | Flag Bit Pattern |
| Mechanism | Insert ESC before flag byte | Insert 0 after 5 consecutive 1s |
| Common Protocols | PPP, SLIP | HDLC |

---

**Summary:**  

- **Byte Stuffing** adds an escape byte to protect special bytes.  
- **Bit Stuffing** adds a 0 bit to protect special bit patterns.  

Both techniques ensure that **frame boundaries are always correctly recognized** by the receiver.

---
### 3. Combination Methods

Protocols often combine methods for reliability:

- **Ethernet & 802.11:** Use a **preamble** for synchronization followed by a **length field** to locate frame end.
- Improves clock sync and frame boundary detection.

---

### 4. Framing in Common Protocols

| Protocol | Type | Framing Method |
| -------- | ---- | -------------- |
| **HDLC** | Bit-oriented | Bit stuffing |
| **PPP** | Byte-oriented | Byte stuffing, HDLC flag byte `0x7E` |
| **T1 Carrier** | Fixed-size | 192 data bits + 1 control bit for sync |
| **SONET** | Fixed-size | 810-byte frames; 2-byte alignment pattern for sync |

---

**Key Takeaways:**

- Framing allows **reliable and structured transmission** over physical links.
- **Error detection** is integrated via **trailer checksums**.
- **Synchronization** is crucial‚Äîachieved via preambles, flags, or reserved signals.
- Different methods are chosen based on **LAN/WAN requirements** and **protocol type**.


---

## Error Control in the Data Link Layer (DLL)

**Error control** ensures that data sent between two directly connected machines arrives **correctly and completely**. The Data Link Layer (Layer 2) transforms a **raw, unreliable physical link** into a communication line that **appears error-free**.

---

### Why Error Control is Needed

- Physical links can introduce **bit errors** due to noise or interference.
- Without error control, **incorrect data** may reach upper layers.
- Ensures **reliability** and **efficiency** by retransmitting only corrupted frames.

---

### How Error Control Works

### 1. Adding Redundancy
- Extra bits are added to each frame to detect or correct errors.
- Common techniques:
  - **Checksums**
  - **Parity bits**
  - **Cyclic Redundancy Check (CRC)**

---

### 2. Main Strategies

#### A. Error Detection and Retransmission (ARQ)
- Detects errors and requests retransmission.
- Efficient for mostly reliable channels.
- Mechanism:
  - Receiver sends **ACK** (acknowledgement) if frame is correct, **NAK** if error detected.
  - Sender uses **timers**; retransmits frame if no ACK received.
  - **Sequence numbers** prevent duplicates.
  - **Sliding window protocols:** Go-Back-N (GBN), Selective Repeat (SR).

#### B. Error Correction (FEC)
- Includes enough redundancy to **correct errors automatically**.
- Useful for noisy channels (e.g., wireless networks).


---

### 5. DLL vs Transport Layer Error Checking

| Layer | Scope | Code Used | Purpose |
|-------|-------|-----------|---------|
| **Data Link Layer** | Single link (hop-to-hop) | CRC, simple checksums | Detect/correct errors between two adjacent machines |
| **Transport Layer** | End-to-end (source to destination) | TCP checksum | Ensure message correctness across the **entire network path** |

---

#### Key Takeaways
- DLL error control **protects frames** on noisy links.
- **ARQ** = detect errors + request retransmission.
- **FEC** = detect errors + correct automatically.
- **Sequence numbers, timers, and checksums** are essential.
- DLL error control improves performance; transport layer checks ensure **end-to-end correctness**.

---
## Checksum in the Data Link Layer (DLL)

A **checksum** is a simple form of **error-detecting code** used by the Data Link Layer (DLL) to ensure that a **frame is received correctly** over a physical link. The checksum adds **redundant information** to the frame, allowing the receiver to detect corrupted data.

---

### Purpose of DLL Checksums

- Detect **transmission errors** in frames between two adjacent nodes.
- Improve **reliability** of data transfer over noisy or unreliable links.
- Often implemented alongside **other error control mechanisms** like **ARQ**.

---

### General Checksum Mechanism

1. **Sender Side:**
   - Compute a checksum based on the **data bits of the frame**.
   - A common method: **sum all data words** and optionally take the **complement**.
   - Append the checksum to the frame before sending.

2. **Receiver Side:**
   - Add all received data words **including the checksum**.
   - If the sum is **0**, the frame is assumed correct.
   - If non-zero, the frame is **corrupted** and typically **discarded**.

---

### Advantages of DLL Checksums

- **Lightweight and fast** for hop-to-hop verification.
- Enables **early detection** of corrupted frames before they reach higher layers.
- Works seamlessly with **ARQ protocols** for retransmission.

---

### Limitations

- Simple checksums may **miss certain error patterns** (e.g., two bits swapped).
- Stronger codes like **CRC** are preferred for robust error detection.
- DLL checksums protect frames only **link-by-link**, not end-to-end.
- End-to-end integrity is ensured by higher layers (Transport Layer checksums).

---

### Summary

In the Data Link Layer:

- **Checksum = simple error-detecting code**.
- Ensures **frame integrity** over a single link.
- Usually combined with **ACK/NAK and retransmission mechanisms**.
- For stronger protection, **CRC is used** in modern protocols like Ethernet and PPP.

---
## Parity, Hamming Distance, and Hamming Codes (Error Detection & Correction)

These techniques are key tools for **Error Detection and Correction** at the **Data Link Layer (DLL)**. They add **redundant bits** to transmitted data so that the receiver can detect or even correct errors.

---

### 1. Hamming Distance

- **Definition:** The **Hamming distance** between two codewords is the **number of bit positions where they differ**.
- **Significance:** Determines error-detection and correction capabilities:
  - To **detect t errors**, minimum distance $d_{\min} = t + 1$.
  - To **correct t errors**, minimum distance $d_{\min} = 2t + 1$.
- **Calculation:** XOR the two codewords and count the 1s.
  
**Example:**
Codeword1: 1011001
Codeword2: 1001101
XOR: 0010100 ‚Üí Hamming distance = 2

> Interpretation: 2 single-bit flips are needed to transform one codeword into the other.

---

### 2. Parity

#### Simple Parity-Check Code

- **Mechanism:** Add **1 parity bit** to a k-bit dataword, forming an n-bit codeword ($n = k+1$).  
- Ensures total number of 1s is **even (even parity)** or **odd (odd parity)**.
- **Detection Capability:**  
  - Hamming distance $d_{\min} = 2$  
  - Can reliably detect **single-bit errors** or **any odd number of errors**.
- **Limitation:** Cannot detect **even number of errors**.

**Example:**

- Dataword: `1011` (4 bits)  
- Even parity: Number of 1s = 3 (odd), so parity bit = 1 ‚Üí Codeword = `10111`  
- If 1 bit flips during transmission: `10011` ‚Üí parity check fails ‚Üí error detected.

#### Parity for Error Correction (Erasures)

- If the **position of the missing bit is known**, parity can reconstruct the lost data.
- **Example:**  
  - Data packets: A = 1010, B = 1100, C = 0110, D = 1001  
  - Parity packet P = A ‚äï B ‚äï C ‚äï D = 0001  
  - If packet B is lost, receiver can compute:  
    `B = P ‚äï A ‚äï C ‚äï D = 0001 ‚äï 1010 ‚äï 0110 ‚äï 1001 = 1100`

---

### 3. Hamming Codes

**Hamming codes** are **linear, systematic block codes** for **single-bit error correction**.

#### Structure & Encoding

1. **Bit Numbering:** Start from 1.
2. **Check Bits:** Positions = powers of 2 (1, 2, 4, 8, ‚Ä¶)
3. **Data Bits:** All other positions.
4. **Parity Rule:** Each check bit enforces **even parity** over specific bits.
5. **Check Assignment:** A data bit at position k is checked by check bits corresponding to powers of 2 in its binary form.

**Example (7,4 Hamming Code):**

- 4 data bits: D1 D2 D3 D4 = `1011`
- Positions: 1 2 3 4 5 6 7 ‚Üí C1 C2 D1 C4 D2 D3 D4 (C = check bit)
- Compute check bits (even parity):
  - C1 checks bits 1,3,5,7 ‚Üí C1 = D1 ‚äï D2 ‚äï D4 = 1 ‚äï 0 ‚äï 1 = 0 (even parity)
  - C2 checks bits 2,3,6,7 ‚Üí C2 = D1 ‚äï D3 ‚äï D4 = 1 ‚äï 1 ‚äï 1 = 1
  - C4 checks bits 4,5,6,7 ‚Üí C4 = D2 ‚äï D3 ‚äï D4 = 0 ‚äï 1 ‚äï 1 = 0
- **Final codeword:** `C1 C2 D1 C4 D2 D3 D4 = 0 1 1 0 0 1 1`  

#### Error Detection & Correction

- **Minimum Hamming distance:** $d_{\min} = 3$  
  ‚Üí Can correct **1 error** or detect **2 errors**.
- **Decoding Process:**
  1. Compute received check bits.
  2. Generate **syndrome**.
  3. Syndrome value indicates **error position**.
  4. Flip the erroneous bit to correct.

**Example of Correction:**

- Received: `0 1 1 0 1 1 1` (bit 5 flipped)  
- Syndrome = 5 ‚Üí flip bit 5 ‚Üí original codeword restored.

#### Usage

- **Memory modules** (ECC RAM), **satellite communication**, **data storage**.
- Networks usually use **stronger codes** like **Convolutional**, **Reed-Solomon**, or **CRC** for error detection and retransmission.

---
### Cyclic Redundancy Check (CRC)

The **Cyclic Redundancy Check (CRC)** is a **strong error-detecting code** widely used at the **Data Link Layer**. It is more powerful than simple parity or checksums and is implemented in hardware for fast detection.

---

### Core Concept: Treating Bits as Polynomials

- A data frame of **k bits** is treated as a polynomial $M(x)$ of degree $k-1$, with **coefficients 0 or 1**.
- Operations are done using **modulo 2 arithmetic (XOR)**.
- A **generator polynomial** $G(x)$ is agreed upon by both sender and receiver. Its high and low bits must be 1.

---

### CRC Computation (Sender Side)

1. **Append Zeros:** Let $r$ = degree of $G(x)$. Append $r$ zeros to the $m$-bit frame ‚Üí $x^r M(x)$.
2. **Modulo 2 Division:** Divide $x^r M(x)$ by $G(x)$ using XOR.
3. **Subtract Remainder:** XOR the remainder with $x^r M(x)$ to get the **checksummed frame $T(x)$**.
4. **Transmit Frame:** Send $T(x)$; it is divisible by $G(x)$.

**Example:**

- Data: `1101` (4 bits), Generator `1011` (degree 3)  
- Append 3 zeros: `1101000`  
- Divide `1101000` by `1011` using XOR ‚Üí remainder `011`  
- Transmitted frame: `1101011` (original + CRC bits)

---

### CRC Verification (Receiver Side)

1. Receive the checksummed frame.
2. Divide it by the same $G(x)$ using modulo 2 division (XOR).
3. **Check Remainder:**
   - `0` ‚Üí no errors detected ‚Üí accept frame
   - Non-zero ‚Üí error detected ‚Üí discard frame

---

### Implementation & Usage

- **Hardware Friendly:** Easily implemented using **shift registers**.
- **Standards:** Used in **Ethernet, 802.11, PPP, SONET, AAL5 (ATM)**.
- **Frame Field:** Often called **Frame Check Sequence (FCS)**; usually 2 or 4 bytes.
- **Speed:** Efficient for real-time transmission due to hardware support.

---

### Error Detection Guarantees

- **Single-bit errors:** Always detected.
- **Odd-numbered errors:** Detected if $G(x)$ divisible by $(x+1)$.
- **Double-bit errors:** Detected if $G(x)$ does not divide $x^k + 1$ for small k.
- **Burst errors:** Excellent performance; e.g., CRC-32 detects all bursts ‚â§ 32 bits.

---

**Key Advantage:** CRC provides strong, fast, and hardware-efficient detection of transmission errors, making it ideal for the Data Link Layer.

---

### Flow Control
Prevents fast sender from overwhelming slow receiver.  

- **Stop-and-Wait ARQ:**  
  Sender sends one frame, waits for ACK. Simple but inefficient.  

- **Sliding Window Protocol:**  
  Sender maintains window of multiple outstanding frames.  

  - **Go-Back-N (GBN):**  
    - Sender can send up to *N* frames before ACK.  
    - On error, receiver discards erroneous + subsequent frames.  
    - Sender retransmits that frame + all after it.  
    - ‚úÖ Simple receiver, ‚ùå wastes bandwidth on errors.  

  - **Selective Repeat (SR):**  
    - Receiver accepts frames out of order and buffers them.  
    - Only retransmits the missing frame(s).  
    - ‚úÖ Efficient bandwidth use, ‚ùå more complex receiver.  

---

## 2. Medium Access Control (MAC Sublayer ‚Äì Lower DLL)

Handles **channel sharing** in broadcast networks (e.g., LANs).  
Controls **who transmits when** and uses **physical addresses**.

---

### Physical Addressing
- Every NIC has a **unique 48-bit MAC address** (e.g., `3C-95-09-4B-32-1A`).  
- Used for **hop-to-hop delivery** inside a LAN.  
- Changes at each hop (router).  
- Switches and bridges forward frames using **MAC tables**.

---

### Random Access Protocols
All stations compete for channel ‚Üí collisions possible.

- **ALOHA:**  
  - Send anytime. Collisions waste channel.  
  - **Slotted ALOHA:** Restricts to time slots, improving efficiency.  

- **CSMA (Carrier Sense Multiple Access):**  
  - Station senses channel before sending.  

  - **CSMA/CD (Collision Detection):**  
    - Used in classic Ethernet (IEEE 802.3).  
    - If collision detected ‚Üí stop, send jamming signal, wait (binary exponential backoff), retry.  
    - Requires full-duplex (hard in wireless).  

  - **CSMA/CA (Collision Avoidance):**  
    - Used in Wi-Fi (IEEE 802.11).  
    - Avoids collisions by waiting (IFS) + using **NAV timers**.  
    - Handles **Hidden Terminal Problem**:  
      - **RTS/CTS (Request to Send / Clear to Send):** handshake before sending data.  

---

### Channelization Protocols
- **FDMA:** Bandwidth divided into frequency slots.  
- **TDMA:** Bandwidth divided into time slots.  
- **CDMA:** Stations use orthogonal codes to share channel simultaneously.  

---

### Comparison: CSMA/CD vs CSMA/CA

| Feature | CSMA/CD (Ethernet) | CSMA/CA (Wi-Fi) |
|---------|--------------------|-----------------|
| Medium  | Wired LAN          | Wireless LAN    |
| Collision Handling | Detects collision, stops transmission | Tries to avoid collisions beforehand |
| Mechanism | Sense ‚Üí Transmit ‚Üí Detect collision | Sense ‚Üí Wait (IFS) ‚Üí RTS/CTS ‚Üí Transmit |
| Efficiency | High in low-collision networks | Better for noisy/wireless networks |
| Used In | IEEE 802.3 Ethernet | IEEE 802.11 Wi-Fi |

---

## Summary of DLL Structure (IEEE 802)

| Sublayer | Role | Key Concepts |
|----------|------|--------------|
| **LLC** (Upper DLL) | Framing, Flow & Error Control | Frames, Checksum, CRC, ARQ, GBN, SR |
| **MAC** (Lower DLL) | Media Access & Addressing | MAC Address, ALOHA, CSMA/CD, CSMA/CA, RTS/CTS |
